import streamlit as st
from datetime import datetime
from langchain_core.messages import HumanMessage, AIMessage, ToolMessage

# Import application components
from config.settings import get_settings
from models.llm import get_llm
from graph.graph_builder import build_state_graph
from     def _render_code_interface(self):
        """Render the code editor interface."""
        # Code editor
        st.subheader("üìù Code Editor")
        st.markdown("*Write, test, and analyze your algorithms*")
        
        # Only handle code execution if not already processing
        if not st.session_state.get("processing", False):
            code_to_run = self.code_editor.render()
            if code_to_run:
                self.handle_code_execution(code_to_run)
        else:
            # Still render the editor but don't handle execution
            self.code_editor.render()s_registry import get_all_tools
from ui.sidebar import Sidebar
from ui.chat_display import ChatDisplay
from ui.chat_input import ChatInput
from ui.code_editor import CodeEditor


class DSASolverApp:
    """Main DSA Solver application class."""
    
    def __init__(self):
        """Initialize the DSA Solver application."""
        self.settings = get_settings()
        self.llm_service = get_llm()
        self.tools = get_all_tools()
        self.app = build_state_graph(self.tools)
        
        # Initialize UI components
        self.sidebar = Sidebar(self.settings)
        self.chat_display = ChatDisplay()
        self.chat_input = ChatInput(on_submit=self.handle_user_input)
        self.code_editor = CodeEditor(on_run_code=self.handle_code_execution)
        
        # Initialize session state
        self._init_session_state()
    
    def _init_session_state(self):
        """Initialize session state variables."""
        if "messages" not in st.session_state:
            st.session_state.messages = []
        
        if "current_thread_id" not in st.session_state:
            st.session_state.current_thread_id = "default"
        
        if "app_state" not in st.session_state:
            st.session_state.app_state = {"messages": []}
        
        if "processing" not in st.session_state:
            st.session_state.processing = False
    
    def handle_user_input(self, user_message: str):
        """Handle user input and process through the LangGraph app."""
        if st.session_state.processing:
            return
        
        try:
            st.session_state.processing = True
            
            # Debug output
            print(f"üîç Processing message: '{user_message}'")
            print(f"üìä Current messages count: {len(st.session_state.messages)}")
            
            # Add user message to session state first (with timestamp)
            timestamp = datetime.now().strftime("%H:%M:%S")
            st.session_state.messages.append({
                "role": "user",
                "content": user_message,
                "timestamp": timestamp
            })
            
            # Create HumanMessage for LangGraph
            human_message = HumanMessage(content=user_message)
            
            # Update app state with new message
            st.session_state.app_state["messages"].append(human_message)
            
            # Store the count of messages before processing to identify new ones
            messages_before_count = len(st.session_state.app_state["messages"])
            print(f"üìù LangGraph messages before: {messages_before_count}")
            
            # Show thinking indicator
            with st.spinner("ü§î Thinking..."):
                # Process the message through the LangGraph app
                result = self.app.invoke(
                    st.session_state.app_state,
                    config={"configurable": {"thread_id": st.session_state.current_thread_id}}
                )
                
                print(f"üß† LangGraph result messages: {len(result.get('messages', []))}")
                
                # Extract only the NEW assistant's response and tool calls
                if "messages" in result and len(result["messages"]) > messages_before_count:
                    # Get only the new messages after our input
                    new_messages = result["messages"][messages_before_count:]
                    print(f"üÜï New messages from LangGraph: {len(new_messages)}")
                    
                    for message in new_messages:
                        if isinstance(message, AIMessage):
                            # Check if this message has tool calls
                            if hasattr(message, 'tool_calls') and message.tool_calls:
                                for tool_call in message.tool_calls:
                                    tool_name = tool_call.get('name', 'Unknown Tool')
                                    
                                    # Map internal tool names to user-friendly names
                                    tool_display_names = {
                                        'python_repl': 'Code Executor',
                                        'generate_hint': 'Hint Generator',
                                        'complexity_analyzer': 'Complexity Analyzer',
                                        'generate_test_cases': 'Test Case Generator',
                                        'persistent_python_repl': 'Code Executor'
                                    }
                                    
                                    display_name = tool_display_names.get(tool_name, tool_name)
                                    
                                    # Add a tool usage indicator to the chat
                                    tool_timestamp = datetime.now().strftime("%H:%M:%S")
                                    st.session_state.messages.append({
                                        "role": "system",
                                        "content": f"üîß Using {display_name}...",
                                        "timestamp": tool_timestamp
                                    })
                                    print(f"üîß Tool used: {tool_name} (displayed as: {display_name})")
                            
                            # Add the actual AI response if it has content
                            if message.content:
                                print(f"‚úÖ Adding AI response: '{message.content[:50]}...'")
                                # Add assistant response to session state
                                assistant_timestamp = datetime.now().strftime("%H:%M:%S")
                                st.session_state.messages.append({
                                    "role": "assistant",
                                    "content": message.content,
                                    "timestamp": assistant_timestamp
                                })
                        
                        elif isinstance(message, ToolMessage):
                            # This is the result of a tool call
                            tool_name = getattr(message, 'name', 'Tool')
                            
                            # Map to user-friendly names
                            tool_display_names = {
                                'python_repl': 'Code Executor',
                                'generate_hint': 'Hint Generator', 
                                'complexity_analyzer': 'Complexity Analyzer',
                                'generate_test_cases': 'Test Case Generator',
                                'persistent_python_repl': 'Code Executor'
                            }
                            
                            display_name = tool_display_names.get(tool_name, tool_name)
                            tool_timestamp = datetime.now().strftime("%H:%M:%S")
                            st.session_state.messages.append({
                                "role": "system",
                                "content": f"‚úÖ {display_name} completed",
                                "timestamp": tool_timestamp
                            })
                            print(f"‚úÖ Tool completed: {tool_name} (displayed as: {display_name})")
                            
                    # Update app state with the complete result
                    st.session_state.app_state = result
                else:
                    print("‚ö†Ô∏è No new messages received from LangGraph")
        
        except Exception as e:
            error_msg = f"Error processing message: {str(e)}"
            st.error(error_msg)
            # Add error message to chat
            error_timestamp = datetime.now().strftime("%H:%M:%S")
            st.session_state.messages.append({
                "role": "assistant",
                "content": f"Sorry, I encountered an error: {str(e)}",
                "timestamp": error_timestamp
            })
        
        finally:
            st.session_state.processing = False
            # Force UI update after processing is complete
            st.rerun()
    
    def handle_code_execution(self, code: str):
        """Handle code execution and analysis."""
        if st.session_state.processing:
            return
        
        try:
            # Simple, clean message for code analysis
            analysis_message = f"""
Please analyze and execute this code:

```python
{code}
```

Please:
1. Check if the code has test cases, if not, add appropriate test cases
2. Execute the complete code and show the output
3. Analyze its time and space complexity  
4. Provide optimization suggestions if needed
5. Explain the algorithm approach

Use your available tools to provide a complete analysis.
"""
            
            # Add user message to show the code execution request
            timestamp = datetime.now().strftime("%H:%M:%S")
            st.session_state.messages.append({
                "role": "user",
                "content": "üîÑ Running code analysis...",
                "timestamp": timestamp
            })
            
            # Process through the regular chat flow
            self.handle_user_input(analysis_message)
            
        except Exception as e:
            st.error(f"Error executing code: {str(e)}")
            st.session_state.processing = False
    
    def render(self):
        """Render the main application interface."""
        # Set page configuration
        st.set_page_config(
            page_title="DSA Solver",
            page_icon="üßÆ",
            layout="wide",
            initial_sidebar_state="expanded"
        )
        
        # Render sidebar
        self.sidebar.render()
        
        # Main title (compact)
        st.title("üßÆ DSA Solver")
        
        # Create side-by-side layout: Code Editor (left) | Chat Mentor (right)
        col1, col2 = st.columns([1.2, 1])
        
        with col1:
            # Code editor interface  
            self._render_code_interface()
        
        with col2:
            # Chat mentor interface
            self._render_chat_interface()
        
        # Auto-scroll to bottom if enabled
        if st.session_state.get("auto_scroll", True):
            st.markdown(
                """
                <script>
                    var element = document.querySelector('.main');
                    element.scrollTop = element.scrollHeight;
                </script>
                """,
                unsafe_allow_html=True
            )
    
    def _render_chat_interface(self):
        """Render the chat interface."""
        # Chat area
        st.subheader("ü§ñ DSA Mentor")
        
        # Display chat messages in a more compact container
        if st.session_state.get("debug_mode", False):
            st.write(f"Debug: Total messages in session: {len(st.session_state.messages)}")
        
        # Chat container with good readability
        chat_container = st.container(height=450)
        with chat_container:
            self.chat_display.render_messages(st.session_state.messages)
        
        # Compact chat input - single line with inline button
        col1, col2 = st.columns([4, 1])
        with col1:
            user_input = st.text_input(
                "Ask:",
                placeholder="Ask about algorithms, get hints...",
                key="mentor_chat_input",
                label_visibility="collapsed"
            )
        with col2:
            if st.button("Send", type="primary", use_container_width=True):
                if user_input.strip():
                    self.handle_user_input(user_input.strip())
                    st.rerun()
        
        # Only 2 compact example prompts when no messages
        if not st.session_state.get("messages", []):
            col1, col2 = st.columns(2)
            with col1:
                if st.button("üí° Get hints", key="example_hints", use_container_width=True):
                    self.handle_user_input("Can you give me a hint?")
                    st.rerun()
            with col2:
                if st.button("üìä Analyze complexity", key="example_complexity", use_container_width=True):
                    self.handle_user_input("What's the time complexity?")
                    st.rerun()
    
    def _render_code_interface(self):
        """Render the code editor interface."""
        # Code editor
        st.subheader("ÔøΩ Code Editor")
        st.markdown("*Write, test, and analyze your algorithms*")
        
        code_to_run = self.code_editor.render()
        
        if code_to_run:
            self.handle_code_execution(code_to_run)


def main():
    """Main application entry point."""
    app = DSASolverApp()
    app.render()


if __name__ == "__main__":
    main()
